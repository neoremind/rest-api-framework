package com.neoremind.apiframework.client;

import com.squareup.okhttp.Interceptor;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.Response;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.concurrent.TimeUnit;

/**
 * <a href="https://github.com/square/okhttp">okhttp</a> client builder.
 * <p>
 * User can specify some parameters like timeout and leverage the retry strategy.
 * Usually this acts like a helper for initializing a <code>ApiClient</code> generated by swagger codegen tool.
 * Sample code shows as below.
 * <pre>
 *  ApiClient client = new ApiClient()
 *                      .setBasePath("http://localhost:8080")
 *                      .setHttpClient(new OkHttpClientBuilder()
 *                           .setConnectTimeout(2000)
 *                           .setReadTimeout(5000)
 *                           .setWriteTimeout(5000)
 *                           .setRetryCount(2).build());
 *
 * HelloworldApi api = new HelloworldApi(client);
 * try {
 *     String response = api.echoMessage("hi");
 *     System.out.println(response);
 * } catch (ApiException e) {
 *     e.printStackTrace();
 * }
 * </pre>
 * <p>
 * For failure handling rule:
 * <ul>
 * <li>If there are any exceptions directly caused from the framework, then rethrow the exception, usually you will get a <code>ApiException</code></li>
 * <li>If there is no exception but server status code is not successful(not between 200 - 300), then you will get a {@link ApiClientException}
 * which wraps the request and response text, but the details information is omitted because response body stream can only be read once.</li>
 * </ul>
 *
 * @author xu.zhang
 */
public class OkHttpClientBuilder {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * connect timeout
     */
    private int connectTimeout = Defaults.CONNECT_TIMEOUT_IN_MS;

    /**
     * read timeout
     */
    private int readTimeout = Defaults.READ_TIMEOUT_IN_MS;

    /**
     * write timeout
     */
    private int writeTimeout = Defaults.WRITE_TIMEOUT_IN_MS;

    /**
     * retry timeout
     */
    private int retryCount = Defaults.RETRY_TIMES;

    /**
     * single failure callback, by default just pretty logging with one line
     */
    private FailCallback failCallback = new FailCallback() {
        @Override
        public void onFail(Request request, Response response, IOException e, int retryTimes) throws IOException {
            if (e != null) {
                logger.error("Failed to call api with request={} and response={} due to {}", request, response, e.getMessage());
            }
        }
    };

    /**
     * all failure callback, when retry count exceeds the limit, by default re-throwing exception out
     */
    private FailCallback allFailCallback = new FailCallback() {
        @Override
        public void onFail(Request request, Response response, IOException e, int retryTimes) throws IOException {
            if (e != null) {
                logger.error("Failed to call api with request={} and response={} {} times due to {}", request, response, retryTimes, e.getMessage(), e);
                throw e;
            }
            if (response != null && !response.isSuccessful()) {
                String msg = String.format("Failed to call api with request=%s and response=%s %d times due to http status code %d is not successful, server text is\n%s", request, response, retryTimes, response.code(), response.message());
                logger.error(msg);
                throw new ApiClientException(msg);
            }
        }
    };

    /**
     * setter
     *
     * @param connectTimeout connectTimeout
     * @return OkHttpClientBuilder
     */
    public OkHttpClientBuilder setConnectTimeout(int connectTimeout) {
        this.connectTimeout = connectTimeout;
        return this;
    }

    /**
     * setter
     *
     * @param readTimeout readTimeout
     * @return OkHttpClientBuilder
     */
    public OkHttpClientBuilder setReadTimeout(int readTimeout) {
        this.readTimeout = readTimeout;
        return this;
    }

    /**
     * setter
     *
     * @param writeTimeout writeTimeout
     * @return OkHttpClientBuilder
     */
    public OkHttpClientBuilder setWriteTimeout(int writeTimeout) {
        this.writeTimeout = writeTimeout;
        return this;
    }

    /**
     * setter
     *
     * @param retryCount retryCount
     * @return OkHttpClientBuilder
     */
    public OkHttpClientBuilder setRetryCount(int retryCount) {
        this.retryCount = retryCount;
        return this;
    }

    /**
     * setter
     *
     * @param failCallback failCallback
     * @return OkHttpClientBuilder
     */
    public OkHttpClientBuilder setFailCallback(FailCallback failCallback) {
        this.failCallback = failCallback;
        return this;
    }

    /**
     * setter
     *
     * @param allFailCallback allFailCallback
     * @return OkHttpClientBuilder
     */
    public OkHttpClientBuilder setAllFailCallback(FailCallback allFailCallback) {
        this.allFailCallback = allFailCallback;
        return this;
    }

    /**
     * Build OkHttpClient
     *
     * @return OkHttpClient
     */
    public OkHttpClient build() {
        OkHttpClient okHttpClient = new OkHttpClient();
        okHttpClient.setReadTimeout(readTimeout, TimeUnit.SECONDS);
        okHttpClient.setWriteTimeout(writeTimeout, TimeUnit.SECONDS);
        okHttpClient.setConnectTimeout(connectTimeout, TimeUnit.SECONDS);
        okHttpClient.interceptors().add(new Interceptor() {
            @Override
            public Response intercept(Chain chain) throws IOException {
                Request request = chain.request();
                Response response = null;
                boolean responseOK = false;
                int tryCount = 0;
                Holder<IOException> exceptionHolder = new Holder<IOException>() {

                    IOException e;

                    @Override
                    public IOException get() {
                        return e;
                    }

                    @Override
                    public void set(IOException e) {
                        this.e = e;
                    }
                };
                while (!responseOK && tryCount <= retryCount) {
                    exceptionHolder.set(null);
                    try {
                        response = chain.proceed(request);
                        responseOK = response.isSuccessful();
                    } catch (final IOException e) {
                        exceptionHolder.set(e);
                        failCallback.onFail(request, response, exceptionHolder.get(), tryCount);
                    } finally {
                        tryCount++;
                    }
                }
                allFailCallback.onFail(request, response, exceptionHolder.get(), tryCount);
                return response;
            }
        });
        return okHttpClient;
    }

    /**
     * Internal holder
     *
     * @param <T> Holding type
     */
    interface Holder<T> {

        /**
         * Return holding object
         *
         * @return holding object
         */
        T get();

        /**
         * Set holding object
         *
         * @param t holding object
         */
        void set(T t);
    }
}
